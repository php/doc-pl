<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 08e58ace7e5b538c8ed75d784a54885d5f785d30 Maintainer: grzesiek Status: ready -->
<!-- $Revision$ -->
<chapter xml:id="language.generators" xmlns="http://docbook.org/ns/docbook">
 <title>Generators</title>

 <sect1 xml:id="language.generators.overview">
  <title>Przegląd generatorów</title>
  <?phpdoc print-version-for="generators"?>

  <para>
   Generatory zapewniają łatwy sposób implementacji prostych 
   <link linkend="language.oop5.iterations">iteratorów</link> without the
   bez narzutu lub złożoności implementacji klasy, która implementuje interfejs
   <classname>Iterator</classname>.
  </para>

  <para>
   Generator oferuje wygodny sposób dostarczania danych do pętli &foreach; bez konieczności
   budowania tablicy w pamięci z wyprzedzeniem, co może spowodować przekroczenie limitu pamięci
   przez program lub wymagać znacznej ilości czasu przetwarzania w celu wygenerowania.
   Zamiast tego można użyć funkcji generatora,
   która jest taka sama jak zwykła
   <link linkend="functions.user-defined">funkcja</link>, z tym wyjątkiem,
   że zamiast
   <link linkend="functions.returning-values">zwracać</link>raz,
   generator może &yield; tyle razy, ile potrzebuje, aby dostarczyć
   wartości do iteracji.
   Podobnie jak w przypadku iteratorów, losowy dostęp do danych nie jest możliwy.
  </para>

  <para>
   Prostym tego przykładem jest ponowne zaimplementowanie funkcji <function>range</function>
   jako generatora. Standardowa funkcja <function>range</function>
   musi wygenerować tablicę z każdą wartością i zwrócić ją, co może
   skutkować dużymi tablicami: na przykład wywołanie
   <command>range(0, 1000000)</command> spowoduje użycie ponad
   100 MB pamięci.
  </para>

  <para>
   Alternatywnie, możemy zaimplementować generator <literal>xrange()</literal>,
   który będzie potrzebował tylko tyle pamięci, aby utworzyć obiekt
   <classname>Iterator</classname> i śledzenia bieżącego stanu
   generatora wewnętrznie, co okazuje się być mniej niż 1 kilobajt..
  </para>

  <example>
   <title>Implementowanie <function>range</function> jako generator</title>
   <programlisting role="php">
<![CDATA[
<?php
function xrange($start, $limit, $step = 1) {
    if ($start <= $limit) {
        if ($step <= 0) {
            throw new LogicException('Step must be positive');
        }

        for ($i = $start; $i <= $limit; $i += $step) {
            yield $i;
        }
    } else {
        if ($step >= 0) {
            throw new LogicException('Step must be negative');
        }

        for ($i = $start; $i >= $limit; $i += $step) {
            yield $i;
        }
    }
}

/*
 * Zauważ, że zarówno range() jak i xrange() dają ten sam
 * wynik poniżej.
 */

echo 'Single digit odd numbers from range():  ';
foreach (range(1, 9, 2) as $number) {
    echo "$number ";
}
echo "\n";

echo 'Single digit odd numbers from xrange(): ';
foreach (xrange(1, 9, 2) as $number) {
    echo "$number ";
}
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
Single digit odd numbers from range():  1 3 5 7 9
Single digit odd numbers from xrange(): 1 3 5 7 9
]]>
   </screen>
  </example>

  <sect2 xml:id="language.generators.object">
   <title>Obiekty <classname>Generator</classname></title>
   <para>
    Po wywołaniu funkcji generatora zwracany jest nowy obiekt wewnętrznej klasy
    <classname>Generator</classname>. Obiekt ten implementuje interfejs
    <classname>Iterator</classname> w taki sam sposób, jak obiekt iteratora
    typu forward-only i udostępnia metody, które mogą być
    wywoływane w celu manipulowania stanem generatora, w tym wysyłania do niego
    wartości i zwracania z niego wartości.
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.generators.syntax">
  <title>Składnia generatora</title>

  <para>
   Funkcja generatora wygląda jak zwykła funkcja, z tą różnicą, że zamiast zwracać wartość,
   instrukcja generatora &yield; zwraca tyle wartości, ile potrzebuje.
   Każda funkcja zawierająca &yield; jest funkcją generatora.
  </para>

  <para>
   Gdy wywoływana jest funkcja generatora, zwraca ona obiekt, nad którym
   można iterować. Podczas iteracji nad tym obiektem (na przykład za pomocą pętli
   &foreach;), PHP wywoła metody iteracyjne obiektu za każdym razem, gdy będzie potrzebować
   wartości, a następnie zapisze stan generatora, gdy generator zwróci wartość,
   aby można go było wznowić, gdy wymagana jest następna wartość.
  </para>

  <para>
   Gdy nie ma już więcej wartości do zwrócenia, generator
   może po prostu powrócić, a kod wywołujący jest kontynuowany tak,
   jakby skończyły się wartości tablicy.
  </para>

  <note>
   <para>
    Generator może zwracać wartości, które mogą być pobierane za pomocą
    <methodname>Generator::getReturn</methodname>.
   </para>
  </note>

  <sect2 xml:id="control-structures.yield">
   <title><command>yield</command> keyword</title>

   <para>
    Sercem funkcji generatora jest słowo kluczowe <command>yield</command>.
    W swojej najprostszej formie, instrukcja yield wygląda podobnie
    do instrukcji return, z tą różnicą, że zamiast zatrzymywać wykonywanie funkcji i
    powracać, yield zamiast tego dostarcza wartość do kodu pętli nad generatorem i
    wstrzymuje wykonywanie funkcji generatora.
   </para>

   <example>
    <title>Prosty przykład zwracania wartości</title>
    <programlisting role="php">
<![CDATA[
<?php
function gen_one_to_three() {
    for ($i = 1; $i <= 3; $i++) {
        // Zauważ, że $i jest zachowywane pomiędzy yieldami.
        yield $i;
    }
}

$generator = gen_one_to_three();
foreach ($generator as $value) {
    echo "$value\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
1
2
3
]]>
    </screen>
   </example>

   <note>
    <para>
     Wewnętrznie, sekwencyjne klucze całkowite zostaną sparowane z zwracanymi
     wartościami, tak jak w przypadku tablicy nieasocjacyjnej.
    </para>
   </note>

   <sect3 xml:id="control-structures.yield.associative">
    <title>Zwracanie wartości z kluczami</title>

    <para>
     PHP również obsługuje tablice asocjacyjne, a generatory niczym się od nich nie różnią.
     Oprócz zwracania prostych wartości, jak pokazano powyżej, można również zwracać
     klucz w tym samym czasie.
    </para>

    <para>
     Składnia do zwracania pary klucz/wartość jest bardzo podobna do tej używanej do
     definiowania tablicy asocjacyjnej, jak pokazano poniżej.
    </para>

    <example>
     <title>Zwracanie pary klucz/wartość</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Dane wejściowe to pola oddzielone średnikami, przy czym pierwsze
 * pole to identyfikator używany jako klucz.
 */

$input = <<<'EOF'
1;PHP;Likes dollar signs
2;Python;Likes whitespace
3;Ruby;Likes blocks
EOF;

function input_parser($input) {
    foreach (explode("\n", $input) as $line) {
        $fields = explode(';', $line);
        $id = array_shift($fields);

        yield $id => $fields;
    }
}

foreach (input_parser($input) as $id => $fields) {
    echo "$id:\n";
    echo "    $fields[0]\n";
    echo "    $fields[1]\n";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1:
    PHP
    Likes dollar signs
2:
    Python
    Likes whitespace
3:
    Ruby
    Likes blocks
]]>
     </screen>
    </example>
   </sect3>

   <sect3 xml:id="control-structures.yield.null">
    <title>Zwracanie wartości null</title>

    <para>
     Yield można wywołać bez argumentu, aby zwrócić wartość &null; z
     automatycznym kluczem.
    </para>

    <example>
     <title>Zwracanie &null;</title>
     <programlisting role="php">
<![CDATA[
<?php
function gen_three_nulls() {
    foreach (range(1, 3) as $i) {
        yield;
    }
}

var_dump(iterator_to_array(gen_three_nulls()));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
array(3) {
  [0]=>
  NULL
  [1]=>
  NULL
  [2]=>
  NULL
}
]]>
     </screen>
    </example>
   </sect3>

   <sect3 xml:id="control-structures.yield.references">
    <title>Zwracanie przez referencję</title>

    <para>
     Funkcje generatora są w stanie zwrócić wartości przez odniesienie, jak również przez
     wartość. Odbywa się to w taki sam sposób jak
     <link linkend="functions.returning-values">zwracanie referencji z funkcji</link>:
     poprzez dodanie znaku ampersand do nazwy funkcji.
    </para>

    <example>
     <title>Zwracanie wartości przez referencję</title>
     <programlisting role="php">
<![CDATA[
<?php
function &gen_reference() {
    $value = 3;

    while ($value > 0) {
        yield $value;
    }
}

/*
 * Zauważ, że możemy zmienić $number wewnątrz pętli, i
 * ponieważ generator zwraca referencje, $value
 * w gen_reference() ulega zmianie.
 */
foreach (gen_reference() as &$number) {
    echo (--$number).'... ';
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
2... 1... 0...
]]>
     </screen>
    </example>
   </sect3>

   <sect3 xml:id="control-structures.yield.from">
    <title>Delegacja generatora poprzez <command>yield from</command></title>

    <para>
     Delegacja generatora pozwala na uzyskanie wartości z innego
     generatora, obiektu <classname>Traversable</classname> lub
     <type>tablicy</type> za pomocą słowa kluczowego <command>yield from</command>.
     Zewnętrzny generator zwróci następnie wszystkie wartości z wewnętrznego generatora,
     obiektu lub tablicy, dopóki nie przestaną one być ważne, po czym wykonanie
     będzie kontynuowane w zewnętrznym generatorze.
    </para>

    <para>
     Jeśli generator jest używany z <command>yield from</command>, wyrażenie
     <command>yield from</command> zwróci również każdą wartość zwróconą
     przez wewnętrzny generator.
    </para>

    <caution>
     <title>Zapisywanie do tablicy (np. za pomocą funkcji <function>iterator_to_array</function>)</title>

      <para>
       <command>yield from</command> nie resetuje kluczy. Zachowuje
       klucze zwrócone przez obiekt <classname>Traversable</classname> lub
       <type>tablicę</type>. Tak więc niektóre wartości mogą mieć wspólny klucz z innym
       <command>yield</command> lub <command>yield from</command>, który po
       wstawieniu do tablicy nadpisze poprzednie wartości tym kluczem.
      </para>

      <para>
       Częstym przypadkiem, w którym ma to znaczenie jest funkcja <function>iterator_to_array</function>
       zwracająca domyślnie tablicę z kluczem, co może prowadzić do nieoczekiwanych wyników.
       <function>iterator_to_array</function> ma drugi parametr
       <parameter>preserve_keys</parameter> który można ustawić na &false;, aby zebrać
       wszystkie wartości, ignorując klucze zwrócone przez  <classname>Generator</classname>.
      </para>

      <example>
       <title><command>yield from</command> z <function>iterator_to_array</function></title>
       <programlisting role="php">
<![CDATA[
<?php
function inner() {
    yield 1; // key 0
    yield 2; // key 1
    yield 3; // key 2
}
function gen() {
    yield 0; // key 0
    yield from inner(); // keys 0-2
    yield 4; // key 1
}
// przekazane false jako drugi parametr, aby uzyskać tablicę [0, 1, 2, 3, 4]
var_dump(iterator_to_array(gen()));
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
array(3) {
  [0]=>
  int(1)
  [1]=>
  int(4)
  [2]=>
  int(3)
}
]]>
       </screen>
      </example>
    </caution>

    <example>
     <title>Podstawowe użycie <command>yield from</command></title>
     <programlisting role="php">
<![CDATA[
<?php
function count_to_ten() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from seven_eight();
    yield 9;
    yield 10;
}

function seven_eight() {
    yield 7;
    yield from eight();
}

function eight() {
    yield 8;
}

foreach (count_to_ten() as $num) {
    echo "$num ";
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1 2 3 4 5 6 7 8 9 10
]]>
     </screen>
    </example>

    <example>
     <title><command>yield from</command> i zwracane wartości</title>
     <programlisting role="php">
<![CDATA[
<?php
function count_to_ten() {
    yield 1;
    yield 2;
    yield from [3, 4];
    yield from new ArrayIterator([5, 6]);
    yield from seven_eight();
    return yield from nine_ten();
}

function seven_eight() {
    yield 7;
    yield from eight();
}

function eight() {
    yield 8;
}

function nine_ten() {
    yield 9;
    return 10;
}

$gen = count_to_ten();
foreach ($gen as $num) {
    echo "$num ";
}
echo $gen->getReturn();
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
1 2 3 4 5 6 7 8 9 10
]]>
     </screen>
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 xml:id="language.generators.comparison">
  <title>Porównanie generatorów z obiektami <classname>Iterator</classname></title>

  <para>
   Podstawową zaletą generatorów jest ich prostota. W porównaniu
   do implementacji klasy <classname>Iterator</classname> należy napisać znacznie
   mniej standardowego kodu, a kod jest ogólnie bardziej czytelny.
   readable. Na przykład, poniższa funkcja i klasa są równoważne:
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
function getLinesFromFile($fileName) {
    if (!$fileHandle = fopen($fileName, 'r')) {
        return;
    }

    while (false !== $line = fgets($fileHandle)) {
        yield $line;
    }

    fclose($fileHandle);
}

// kontra...

class LineIterator implements Iterator {
    protected $fileHandle;

    protected $line;
    protected $i;

    public function __construct($fileName) {
        if (!$this->fileHandle = fopen($fileName, 'r')) {
            throw new RuntimeException('Couldn\'t open file "' . $fileName . '"');
        }
    }

    public function rewind() {
        fseek($this->fileHandle, 0);
        $this->line = fgets($this->fileHandle);
        $this->i = 0;
    }

    public function valid() {
        return false !== $this->line;
    }

    public function current() {
        return $this->line;
    }

    public function key() {
        return $this->i;
    }

    public function next() {
        if (false !== $this->line) {
            $this->line = fgets($this->fileHandle);
            $this->i++;
        }
    }

    public function __destruct() {
        fclose($this->fileHandle);
    }
}
?>
]]>
   </programlisting>
  </informalexample>

  <para>
   Ta elastyczność ma jednak swoją cenę: generatory są iteratorami tylko do przodu
   i nie można ich przewinąć po rozpoczęciu iteracji. Oznacza to również,
   że ten sam generator nie może być iterowany wielokrotnie:
   generator będzie musiał zostać odbudowany poprzez ponowne wywołanie funkcji generatora.
  </para>

  <simplesect role="seealso">
   &reftitle.seealso;
   <para>
    <simplelist>
     <member><link linkend="language.oop5.iterations">Iteracja obiektu</link></member>
    </simplelist>
   </para>
  </simplesect>

 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
