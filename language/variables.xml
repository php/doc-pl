<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: b6654cdfa5a130df41b891e4b93326a552b4bb7e Maintainer: sobak Status: ready -->
<!-- $Revision$ -->
<!-- CREDITS: garbus, qrak -->
 <chapter xml:id="language.variables" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Zmienne</title>
  
  <sect1 xml:id="language.variables.basics">
   <title>Podstawy</title>

   <simpara>
    Każdą zmienną w PHP zapisuje się, poprzedzając jej nazwę znakiem dolara "$".
    Wielkość liter w nazwie zmiennej jest rozróżniana.
   </simpara>

   <para>
    Nazw zmiennych dotyczą te same reguły, co innych rodzajów nazw w PHP.
    Poprawna nazwa zmiennej zaczyna się od litery lub znaku podkreślenia "_",
    po których może wystąpić dowolna ilość liter, cyfr lub znaków podkreślenia.
    Jako wyrażenie regularne, można to zapisać tak:
    '<literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>'
   </para>
   
   <note>
    <simpara>
     W naszym rozumieniu, litery to znaki a-z, A-Z i bajty od 127 do
     255 (<literal>0x7f-0xff</literal>).
    </simpara>
   </note>

   <note>
    <simpara>
     <literal>$this</literal> to specialna zmienna, której nie można
     definiować.
    </simpara>
   </note>

   &tip.userlandnaming;

   <para>
    Aby uzyskać więcej informacji na temat funkcji powiązanych ze zmiennymi, zobacz
    <link linkend="ref.var">Funkcje Obsługi Zmiennych</link>.
   </para>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$zmienna = 'Pan';
$Zmienna = 'Jan';
echo "$zmienna, $Zmienna";  // wyświetla "Pan, Jan"

$7dni = 'tydzień';          // niepoprawna nazwa - zaczyna się od cyfry
$_7dni = 'tydzień';         // poprawna nazwa - zaczyna się znakiem podkreślenia
$jaŹń = 'osobowość';        // poprawna nazwa - "ń" i "Ź" należą do (rozszerzonego) ASCII 228
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Domyślnie, zmienne zawsze są zawsze przypisywane przez wartość. Innymi
    słowy, jeśli przypiszesz do zmiennej jakieś wyrażenie, wartość tego
    wyrażenia zostanie skopiowana do zmiennej. Oznacza to, że po przypisaniu
    wartości jednej zmiennej do drugiej, późniejsza 
    zmiana wartości jednej z nich nie spowoduje zmiany wartości drugiej.
    Więcej informacji na ten temat w
    rozdziale <link 
    linkend="language.expressions">Wyrażenia</link>.
   </para>
   <para>
    PHP oferuje jeszcze jeden sposób przypisywania wartości do zmiennych:
    <link linkend="language.references">przypisanie przez referencję</link>.
    Oznacza to, że nowa zmienna tylko odnosi się (innymi słowy, 
    "staje się aliasem" lub "wskazuje na") do pierwotnej zmiennej. 
    Zmiany wykonane na nowej zmiennej oddziałują także na pierwotną zmienną i vice versa. 
   </para>
   <para>
    Aby przypisać przez referencję, postaw znak ampersand (&amp;)
    przed nazwą zmiennej przypisywanej (zmiennej od której pobierasz
    wartość). Na przykład poniższy kod wyświetla "<literal>To jest 
    PHP</literal>" dwa razy:
    
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "PHP";               // Przypisz wartość "PHP" do $foo.
$bar = &$foo;               // Przypisz referencyjnie $foo do $bar.
$bar = "To jest $bar";      // Zmień $bar...
echo $bar;
echo $foo;                  // $foo też się zmieniło.
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <para>
    Należy pamiętać, że tylko wyrażenia posiadające nazwę mogą być przypisane
    przez referencję.
    <informalexample>
     <programlisting role="php">
<![CDATA[ 
<?php
$foo = 25;
$bar = &$foo;      // Przypisanie poprawne.
$bar = &(24 * 7);  // Przypisanie niepoprawne - do nienazwanego wyrażenia.

function test()
{
   return 25;
}

$bar = &test();    // Niepoprawne.
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   
   <para>
    W PHP nie jest konieczne inicjowanie zmiennych, jednak jest to bardzo
    dobry nawyk. Niezainicjowane zmienne mają domyślne wartości dla ich typu, zależnie od kontekstu, w jaki zmienne te zostały użyte
    - zmienne logiczne typu boolean domyślnie przyjmują wartość &false;, zmiennym całkowitym typu integer domyślnie nadawane jest zero, łańcuchom tekstowym
    (np. użytym wewnątrz <function>echo</function>) nadany jest łańcuch pusty, natomiast tablice zostają pustymi tablicami.
   </para>
   <para>
    <example>
     <title>Domyślne wartości niezainicjowanych zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
// Zmienna bez nadanej wartości ORAZ bez odwołań do niej (brak kontekstu, w jakim została użyta); zwróci NULL
var_dump($zmienna_bez_kontekstu_uzycia);

// Używanie zmiennej logicznej typu boolean; zwróci 'false' (Zobacz informacje o operatorach trójparametrowych, by poznać tę składnię)
echo($nieinicjowana_zmiena_bool ? "true\n" : "false\n");

// Używanie łańcuchów; zwróci 'string(3) "abc"'
$nieinicjowany_lancuch .= 'abc';
var_dump($nieinicjowany_lancuch);

// Używanie zmiennych całkowitych; zwróci 'int(25)'
$nieinicjowana_zmienna_int += 25; // 0 + 25 => 25
var_dump($nieinicjowana_zmienna_int);

// Używanie zmiennych typu float/double; zwróci 'float(1.25)'
$nieinicjowana_zmienna_float += 1.25;
var_dump($nieinicjowana_zmienna_float);

// Używanie tablicy; zwróci array(1) {  [3]=> string(3) "def" }
$nieinicjowana_tablica[3] = "def"; // array() + array(3 => "def") => array(3 => "def")
var_dump($nieinicjowana_tablica);

// Używanie obiektu; stworzy nowy obiekt stdClass (zobacz http://www.php.net/manual/pl/reserved.classes.php)
// Zwróci: object(stdClass)#1 (1) {  ["foo"]=>  string(3) "bar" }
$nieinicjowany_obiekt->foo = 'bar';
var_dump($nieinicjowany_obiekt);
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Poleganie na domyślnej wartości niezainicjowanej zmiennej jest problematyczne,
    w razie zawarcia jednego pliku wewnątrz innego, posiadającego tak samo
    nazwane zmienne. Jest to również poważne <link
    linkend="security.globals">zagrożenie dla bezpieczeństwa</link> przy włączonej opcji <link
    linkend="ini.register-globals">register_globals</link>. Ostrzeżenie klasy <link
    linkend="errorfunc.constants.errorlevels.e-notice">E_NOTICE</link> pojawi się podczas
    pracy z niezainicjowanymi zmiennymi, jednak w przypadku przypisywania
    elentów do niezainicjowanych tablic - już nie. Funkcja <function>isset</function> 
    może zostać użyta w celu wykrycia, czy zmienna została już zainicjowana.
   </para>
  </sect1>

  <sect1 xml:id="language.variables.predefined">
   <title>Zmienne Predefiniowane</title>

   <simpara>
    PHP udostępnia dla każdego pracującego skryptu dużą ilość predefiniowanych
    zmiennych. Jednakże wiele spośród tych zmiennych nie może być w pełni
    objaśnionych, gdyż są zależne od rodzaju serwera, jego wersji, ustawień
    i innych czynników. Niektóre z tych zmiennych nie będą dostępne dla
    skryptów PHP uruchomionych z 
    <link linkend="features.commandline">Linii Poleceń</link>. 
    Lista tych zmiennych znajduje się w rozdziale 
    <link linkend="reserved.variables">Predefiniowane Zmienne</link>. 
   </simpara>

   <warning>
    <simpara>
     W PHP 4.2.0 i późniejszych, domyślne ustawienie dla instrukcji PHP <link
     linkend="ini.register-globals">register_globals</link> jest 
     <emphasis>wyłączone</emphasis>. Jest to bardzo istotna zmiana w PHP. Mając opcję
     register_globals <emphasis>wyłączoną</emphasis> wpływamy na ustawienie zmiennych
     predefiniowanych, dostępnych globalnie. Na przykład, aby poznać wartość
     <varname>DOCUMENT_ROOT</varname> użyjesz
     <varname>$_SERVER['DOCUMENT_ROOT']</varname> zamiast
     <varname>$DOCUMENT_ROOT</varname>, lub <varname>$_GET['id']</varname>
     z adresu URL <literal>http://www.example.com/test.php?id=3</literal> zamiast
     <varname>$id</varname>, albo <varname>$_ENV['HOME']</varname> a nie
     <varname>$HOME</varname>.
    </simpara>
    <simpara> 
     Aby uzyskać informacje powiązane z tą zmianą, przeczytaj część o konfiguracji
     <link linkend="ini.register-globals">register_globals</link>, rozdziału
     o bezpieczeństwie <link linkend="security.globals">Używanie Register Globals
     </link>, oraz w informacjach o wydaniu (ang. Release Announcements) PHP <link xlink:href="&url.php.release4.1.0;">
     4.1.0</link> jak i <link xlink:href="&url.php.release4.2.0;">
     4.2.0</link>
    </simpara>
    <simpara>
     Używanie dostępnych zmiennych predefiniowanych, jak 
     <link linkend="language.variables.superglobals">tablice superglobalne</link>, 
     jest zalecane.
    </simpara>
   </warning>
   
   <simpara>
    Począwszy od wersji 4.1.0, PHP udostępnia dodatkowo zestaw predefiniowanych tablic,
    które zawierają zmienne serwera, zmienne środowiskowe oraz zmienne
    użytkownika. Tablice te są dość specyficzne, gdyż
    są one automatycznie globalne, tzn. automatycznie
    dostępne w każdym miejscu. Dlatego nazywa się
    je "superglobalami". (W PHP nie ma mechanizmu pozwalającego użytkownikowi na definiowanie
    własnych superglobali.) Superglobale PHP wymienione są poniżej;
    jednakże wykaz ich zawartości i głębsze omówienie
    prefiniowanych zmiennych PHP oraz ich natury znajduje się w rozdziale
    <link linkend="reserved.variables">predefiniowane zmienne</link>.
    Zauważ także, że starsze zmienne predefiniowane 
    (<varname>$HTTP_*_VARS</varname>) wciąż funkcjonują.

    &avail.register-long-arrays;
   </simpara>

   <note>
    <title>Zmienne zmienne</title>
    <para>
     Zmienne superglobale nie mogą być użyte jako
     <link linkend="language.variables.variable">zmienne zmienne</link>
     wewnątrz funkcji, ani jako metody klasy.
    </para>
   </note>
   
   <note>
    <para>
     Nawet pomimo tego, że zmienne superglobalne i <literal>HTTP_*_VARS</literal> mogą istnieć w tym samym
     czasie; nie są one tożsame, czyli zmiana jednej nie zmieni drugiej.
    </para>
   </note>
   
   <para>
    Jeśli pewne zmienne w <link
    linkend="ini.variables-order">variables_order</link> nie są ustawione, to ich
    odpowiedniki zmiennych predefiniowanych PHP również są puste.
   </para>
  </sect1>


  <sect1 xml:id="language.variables.scope">
   <title>Zasięg zmiennych</title>

   <simpara>
    Zasięg zmiennej zależy od miejsca, w jakim ją zdefiniowano.
    Najczęściej zmienne PHP widoczne są tylko w jednym zasięgu.
    Taki zasięg obejmuje również pliki dołączone funkcjami include i require.  Na
    przykład:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1;
include 'b.inc';
?>
]]>
    </programlisting>
   </informalexample>
   <simpara>
    Tutaj zmienna <varname>$a</varname> będzie dostępna także wewnątrz dołączonego
    funkcją include pliku <filename>b.inc</filename> w skrypcie. Jednakże wewnątrz
    funkcji zdefiniowanych samodzielnie zmienne mają zasięg lokalny. Każda
    zmienna użyta wewnątrz funkcji jest domyślnie ograniczona do zasięgu lokalnego
    funkcji.  Na przykład:
   </simpara>
    
   <informalexample>
    <programlisting role="php"> 
<![CDATA[
<?php
$a = 1; /* zasięg globalny */ 

function test()
{ 
    echo $a; /* odwołanie do zmiennej o zasięgu lokalnym */ 
} 

test();
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Ten skrypt nie wyświetli niczego, ponieważ instrukcja echo
    odwołuje się do zmiennej lokalnej <varname>$a</varname>,
    której jak dotąd nie została przypisana żadna wartość. Można
    tu zauważyć różnicę w stosunku do języka C, gdzie
    zmienne globalne są zawsze dostępne wewnątrz
    definicji funkcji, o ile nie zostały nadpisane przez lokalną definicję
    zmiennej. Może to spowodować problem, że ktoś może nieodwracalnie
    zmienić wartość zmiennej globalnej. W PHP zmienne globalne muszą
    być jawnie określone jako globalne wewnątrz funkcji, w której mają być użyte, 
    do czego używamy słowa kluczowego global.
   </simpara>

   <sect2 xml:id="language.variables.scope.global">
    <title>Polecenie <literal>global</literal></title>
    <simpara>
     Najpierw, przykład użycia <literal>global</literal>:
    </simpara>
    <para>
     <example>
      <title>Używanie polecenia <literal>global</literal></title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function suma()
{
    global $a, $b;

    $b = $a + $b;
}

suma();
echo $b;
?>
]]>
      </programlisting>
     </example>
    </para>

   <simpara>
    Powyższy skrypt wyświetli wynik <literal>3</literal>.  Przez zadeklarowanie
    wewnątrz funkcji globalności zmiennych <varname>$a</varname> i
    <varname>$b</varname>, wszystkie odwołania do tych zmiennych 
    będą odnosiły się do ich globalnych wersji. Nie ma żadnych ograniczeń
    w ilości zmiennych globalnych, na których chcemy operować wewnątrz funkcji.
   </simpara>

   <simpara>
    Drugim sposobem uzyskania dostępu do zmiennych globalnych wewnątrz funkcji
    jest użycie specjalnej, zdefiniowanej przez PHP tablicy 
    <varname>$GLOBALS</varname>. Powyższy przykład można zatem przepisać tak:
   </simpara>
   <para>
    <example>
     <title>Używanie <varname>$GLOBALS</varname> zamiast polecenia global</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = 2;

function Suma()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
}

Suma();
echo $b;
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    Tablica <varname>$GLOBALS</varname> jest asocjacyjną tablicą,
    w której nazwa zmiennej jest kluczem, a zawartość zmiennej
    wartością komórki tablicy.
    Zauważ, że <varname>$GLOBALS</varname> jest dostępna z każdego miejsca,
    ponieważ <varname>$GLOBALS</varname> jest <link
    linkend="language.variables.superglobals">tablicą superglobalną</link>.
    Poniżej przykład demonstrujący moc superglobali:
   </simpara>
   <para>
    <example>
     <title>Przykład demonstrujący superglobale i zasięg zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
function test_global()
{
    // Większość predefiniowanych zmiennych nie jest "super i wymaga
    // 'global', by być dostępnymi w zasięgu lokalnym funkcji.
    global $HTTP_POST_VARS;
    
    echo $HTTP_POST_VARS['name'];
    
    // Superglobale są dostępne z każdego miejsca 
    // i nie wymagają 'global'. Superglobale udostępniono
    // wraz z PHP 4.1.0, a HTTP_POST_VARS jest 
    // uważane za przestarzałe.
    echo $_POST['name'];
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <note>
    <para>
     Użycie <literal>global</literal> poza funkcją nie jest
     błędem. Może on zostać użyty jeżeli plik jest dołączany z wnętrzna funkcji.
    </para>
   </note>
  </sect2>
 
  <sect2 xml:id="language.variables.scope.static">
   <title>Używanie zmiennych statycznych</title>
   <simpara>
    Jeszcze jedną ważną rzeczą, związaną z zasięgiem zmiennych jest zmienna
    statyczna (ang. <emphasis>static</emphasis> variable). Zmienna statyczna
    może mieć wyłącznie zasięg lokalny, ale nie traci swojej wartości, kiedy
    program opuści ten zasięg lokalny, w którym dana zmienna statyczna się
    znajduje. Rozważmy poniższy przykład:
   </simpara>
   <para>
    <example>
     <title>Przykład ukazujący przydatność zmiennych statycznych</title>
     <programlisting role="php">
<![CDATA[
<?php
function test()
{
    $a = 0;
    echo $a;
    $a++;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara> 
    Ta funkcja jest bezużyteczna, gdyż przy każdym jej wywołaniu zmienna
    <varname>$a</varname> otrzymuje wartość <literal>0</literal>, w związku
    z czym funkcja stale wyświetla <literal>0</literal>. Występująca potem
    inkrementacja <varname>$a</varname>++ nie ma żadnego znaczenia, gdyż
    funkcja się kończy i zmienna <varname>$a</varname> znika. Aby powyższa
    funkcja miała jakiś sens, należy zapobiec gubieniu wartości
    <varname>$a</varname>, do czego używamy słowa kluczowego static:
   </simpara>
   <para>
    <example>
     <title>Przykład użycia zmiennych statycznych</title>
     <programlisting role="php">
<![CDATA[
<?php
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Teraz, <varname>$a</varname> jest inicjowana tylko przy pierwszym wywołaniu funkcji
    a, przy każdym wywołaniu funkcji <literal>test()</literal>, zostanie wyświetlona wartość
    zmiennej <varname>$a</varname>, po czym ta zmienna zostanie inkrementowana.
   </simpara>

   <simpara>
    Zmienne statyczne pozwalają też na wykorzystanie funkcji rekurencyjnych,
    czyli takich, które wywołują same siebie. Funkcje rekurencyjne
    należy pisać ostrożnie, gdyż łatwo jest wywołać nieskończoną
    rekurencję. Musisz być pewny, że masz odpowiednie mechanizmy
    do zatrzymania rekurencji w jakimś momencie. Poniższa, prosta
    funkcja rekurencyjnie liczy do 10, używając zmiennej
    statycznej <varname>$licznik</varname>, aby wiedzieć, kiedy się zatrzymać:
   </simpara>
   <para>
    <example>
     <title>Zmienne statyczne w funkcjach rekurencyjnych</title>
     <programlisting role="php">
<![CDATA[
<?php
function test()
{
    static $licznik = 0;

    $licznik++;
    echo $licznik;
    if ($licznik < 10) {
        test();
    }
    $licznik--;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <note>
    <para>
     Zmienne statyczne mogą być deklarowane, tak jak w powyższym przykładzie.
     Próba przypisania wartości do tego typu zmiennych, poprzez wynik
     jakiegoś wyrażenia, spowoduje błąd składni (ang. Parse error).
    </para>
    <para>
     <example>
      <title>Deklaracja zmiennych statycznych</title>
      <programlisting role="php">
<![CDATA[
<?php
function foo(){
    static $int = 0;          // prawidłowo
    static $int = 1+2;        // błąd  (w rzeczywistości to jest wyrażenie)
    static $int = sqrt(121);  // błąd  (to również jest wyrażenie)

    $int++;
    echo $int;
}
?>
]]>
      </programlisting>
     </example>
    </para>
   </note>
   <note>
    <para>
     Deklaracje statyczne są rozwiązywane w czasie kompilacji.
    </para>
   </note>
  </sect2>

  <sect2 xml:id="language.variables.scope.references">
   <title>Referencje do zmiennych statycznych i globalnych</title>
   <simpara>
    Silnik Zend 1 (ang. Zend Engine 1) napędzający PHP4, implementuje modyfikatory
    <link linkend="language.variables.scope.static">statyczny</link> oraz
    <link linkend="language.variables.scope.global">globalny</link>
    dla zmiennych, pod względem <link linkend="language.references">
    referencji</link>. Na przykład, w rzeczywistości globalna zmienna
    wprowadzona wewnątrz zasięgu funkcji z wyrażeniem <literal>global</literal>
    na dziś dzień tworzy referencję do zmiennej globalnej. Takie zachowanie może
    prowadzić do nieoczekiwanych sytuacji, czego dowodzi poniższy przykład:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?>
]]>
    </programlisting>
   </informalexample>

   &example.outputs;

   <screen>
NULL
object(stdClass)(0) {
}
   </screen>

   <simpara>
    Podobna sytuacja dotyczy deklaracji <literal>static</literal>.
    Referencje nie są magazynowane statycznie:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
function &get_instance_ref() {
    static $obj;

    echo 'Obiekt statyczny: ';
    var_dump($obj);
    if (!isset($obj)) {
        // Przypisanie referencji do zmiennej statycznej.
    $obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo 'Obiekt statyczny: ';
    var_dump($obj);
    if (!isset($obj)) {
        // Przypisanie do obiektu zmiennej statycznej
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?>
]]>
    </programlisting>
   </informalexample>

   &example.outputs;

   <screen>
Obiekt statyczny: NULL
Obiekt statyczny: NULL

Obiekt statyczny: NULL
Obiekt statyczny: object(stdClass)(1) {
  ["property"]=>
  int(1)
}
   </screen>
          
   <simpara>
    Ten przykład pokazuje, że podczas przypisywania referencji do zmiennej
    statycznej, nie następuje <emphasis>zapamiętanie</emphasis>, gdy wywołasz
    funkcję <literal>&amp;get_instance_ref()</literal> po raz drugi.
   </simpara>
   </sect2>
  </sect1>

  <sect1 xml:id="language.variables.variable">
   <title>Zmienne zmienne</title>

   <simpara>
    W niektórych przypadkach jest wygodne, by móc użyć zmiennej o zmiennej
    nazwie. To znaczy zmiennej, której nazwa może być zmieniana dynamicznie.
    Zwykła zmienna jest ustawiana wyrażeniem jak poniżej:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = "witaj";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Zmienna zmienna pobiera wartość jednej zmiennej i traktuje ją
    jako nazwę innej.  W powyższym przykładzie,
    <emphasis>witaj</emphasis>, może stać się nazwą zmiennej,
    dzięki użyciu dwóch znaków dolara, tzn.
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$$a = "świecie";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    W tym momencie dwie zmienne zostały zdefiniowane i umieszczone w drzewie
    symbolicznym PHP: <varname>$a</varname> zawierająca "witaj" i 
    <varname>$witaj</varname> zawierająca "świecie". Zatem poniższy
    zapis:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a ${$a}";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    znaczy to samo, co:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
echo "$a $witaj";
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    tzn. obydwa wyświetlą: <computeroutput>witaj świecie</computeroutput>.
   </simpara>

   <simpara>
    Aby używać zmiennych zmiennych jako tablic, trzeba
    wyjaśnić pewną niejasność. Mianowicie, jeśli napiszesz
    <varname>$$a[1]</varname>, parser musi wiedzieć, czy
    chesz użyć <varname>$a[1]</varname> jako nazwy zmiennej, czy
    <varname>$$a</varname> jako nazwy tablicy, której rekord [1] cię
    interesuje. W tym przypadku należy zastosować odrębną
    składnię: <varname>${$a[1]}</varname> dla pierwszego przypadku a
    <varname>${$a}[1]</varname> dla drugiego.
   </simpara>

  <simpara>
    Dostęp do właściwości klas można uzyskać także za pomocą zmiennej nazwy
    własności. Zmienna nazwa własności zostanie zinterpretowana w
    zasięgu z którego jest wywoływana. Przykładowo, jeżeli masz
    wyrażenie takie jak <varname>$foo->$bar</varname>, to zasięg
    lokalny będzie przeszukany pod kątem <varname>$bar</varname> i jej wartość
    zostanie użyta jako nazwa własności
    of <varname>$foo</varname>. Jest to także prawdą
    jeżeli <varname>$bar</varname> jest dostępem do tablicy.
   </simpara>
   <simpara>
    Do jasnego ograniczenia nazwy własności można wykorzystać też nawiasy
    klamrowe. Są one szczególnie użyteczne, gdy uzyskuje się dostęp do właściwości
    zawierającej tablicę, gdy nazwa własności jest składana z wielu części
    lub gdy nazwa własności zawiera znaki, które nie są
    w innym wypadku prawidłowe (np. z <function>json_decode</function>
    lub <link linkend="book.simplexml">SimpleXML</link>).
   </simpara>

   <para>
    <example>
     <title>Przykład zmiennej własności</title>
      <programlisting role="php">
<![CDATA[
<?php
class foo {
    var $bar = 'I am bar.';
    var $arr = array('I am A.', 'I am B.', 'I am C.');
    var $r   = 'I am r.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo $foo->$bar . "\n";
echo $foo->$baz[1] . "\n";

$start = 'b';
$end   = 'ar';
echo $foo->{$start . $end} . "\n";

$arr = 'arr';
echo $foo->$arr[1] . "\n";
echo $foo->{$arr}[1] . "\n";

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
I am bar.
I am bar.
I am bar.
I am r.
I am B.
     </screen>
    </example>
   </para> 

   <warning>   
    <simpara>
     Zauważ, że zmienne zmienne nie mogą być używane z
     <link linkend="language.variables.superglobals">Tablicami superglobalnymi</link>
     PHP, wewnątrz funkcji, czy metod klas. Zmienna <literal>$this</literal>
     jest także specjalną zmienną, dla której referencje dynamiczne nie są dozwolone.
    </simpara>
   </warning>

  </sect1>

  <sect1 xml:id="language.variables.external">
   <title>Zmienne ze źródeł zewnętrznych</title>

   <sect2 xml:id="language.variables.external.form">
    <title>Formularze HTML (GET i POST)</title>

    <simpara>
     Kiedy do skryptu PHP zostanie wysłany formularz, informacja
     z niego jest automatycznie dostępna w skrypcie. Istnieje
     kilka sposobów na uzyskanie tych informacji, dla przykładu:
    </simpara>

    <para>
     <example>
      <title>Prosty formularz HTML</title>
      <programlisting role="html">
<![CDATA[
<form action="foo.php" method="post">
    Imie:  <input type="text" name="imie" /><br />
    Email: <input type="text" name="email" /><br />
    <input type="submit" name="submit" value="Wyslij!" />
</form>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Począwszy od PHP 5.4 istnieją tylko dwie drogi uzyskiwania dostępu do informacji z formularza.
     Obecnie dostępne metody zostały wymienione poniżej:
    </para>

    <para>
     <example>
      <title>Dostęp do informacji z prostego formularza HTML (wysłanego metodą POST)</title>
      <programlisting role="php">
<![CDATA[
<?php
echo $_POST['imie'];
echo $_REQUEST['imie'];
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     W starszych wersjach PHP istniało kilka innych metod uzyskiwania dostępu do danych od użytkownika. Zostały
     one pokazane poniżej. Spójrz na wykaz zmian na dole strony, aby uzyskać więcej szczegółów.
     <example>
      <title>Starsze metody pobierania danych od użytkownika</title>
      <programlisting role="php">
<![CDATA[
<?php
// UWAŻAJ: te metody NIE są dłużej wspierane.
// Poprawne zostały opisane powyżej

// Używając import_request_variables() - ta funkcja została usunięta w PHP 5.4.0
   import_request_variables('p', 'p_');
   echo $p_imie;

// Długie zmienne predefiniowane zostały usunięte w PHP 5.4.0
   echo $HTTP_POST_VARS['imie'];

// Używając register_globals. Ta możliwość została usunięta w PHP 5.4.0
   echo $imie;
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Przesyłanie danych z formularza metodą GET jest podobne, z takim wyjątkiem, że użyjesz
     zmienną predefiniowaną odpowiednią dla tej metody, zamiast poprzedniej. GET także
     odnosi się do tzw. <literal>QUERY_STRING</literal> (informacje w adresie URL, po znaku '?'). Tak więc,
     dla przykładu, <literal>http://www.example.com/test.php?id=3</literal>
     zawiera dane dla metody GET, dostępne poprzez <varname>$_GET['id']</varname>.
     Zobacz także <varname>$_REQUEST</varname>.
    </para>

    <note>
     <para>
      Spacje i kropki w nazwach zmiennych są konwertowane do znaków podkreślenia. Na
      przykład <literal>&lt;input name="a.b" /&gt;</literal> staje się zmienną
      <literal>$_REQUEST["a_b"]</literal>.
     </para>
    </note>

    <simpara>
     PHP obsługuje także tablice w kontekście zmiennych z formularzy 
     (zajrzyj do <link linkend="faq.html">FAQ</link>). Można 
     na przykład pogrupować razem powiązane zmienne lub użyć tej 
     możliwości do pobrania wartości z pola wyboru (select). Na 
     przykład, wyślijmy formularz z pliku metodą POST do samego siebie
     i wyświetlmy te dane:
    </simpara>

    <para>
     <example>
      <title>Bardziej złożone zmienne w formularzach</title>
      <programlisting role="php">
<![CDATA[
<?php
if ($_POST) {
    echo '<pre>';
    echo htmlspecialchars(print_r($_POST, true));
    echo '</pre>';
}
?>
<form action="" method="post">
    Nazwisko: <input type="text" name="personal[nazwisko]"><br />
    Email: <input type="text" name="personal[email]"><br />
    Piwo: <br />
    <select multiple name="piwo[]">
        <option value="zywiec">Żywiec</option>
        <option value="tyskie">Tyskie</option>
        <option value="lech">Lech</option>
    </select><br />
    <input type="submit" value="Wyślij mnie!" />
</form>
]]>
      </programlisting>
     </example>
    </para>

    <sect3 xml:id="language.variables.external.form.submit">
     <title>Nazwy zmiennych dla SUBMIT w postaci obrazka</title>

     <simpara>
      Przy tworzeniu formularza, można użyć obrazka, zamiast standardowego
      przycisku Wyślij, za pomocą takiego znacznika:
     </simpara>

     <informalexample>
      <programlisting role="html">
<![CDATA[
<input type="image" src="obrazek.gif" name="sub" />
]]>
      </programlisting>
     </informalexample>

     <simpara>
      Kiedy użytkownik kliknie gdzieś na obrazku, formularz, którego
      to dotyczy, zostanie wysłany do serwera z dwiema dodatkowymi
      zmiennymi, <varname>sub_x</varname> i <varname>sub_y</varname>. Zawierają one współrzędne miejsca
      kliknięcia na obrazek. Można przy tym zauważyć, że
      na razie w nazwach zmiennych znajduje się kropka
      zamiast podkreślnika, ale PHP konwertuje kropkę na
      podkreślnik automatycznie.
     </simpara>
    </sect3>

   </sect2>

   <sect2 xml:id="language.variables.external.cookies">
    <title>Ciasteczka HTTP</title>

    <simpara>
     PHP bez problemu obsługuje ciasteczka HTTP, tak jak zdefiniowano w <link
     xlink:href="&url.rfc;6265">RFC 6265</link>. Ciasteczka są
     mechanizmem przechowywania informacji w przeglądarce klienta w celu
     śledzenia lub identyfikowania stałych bywalców strony. Ciasteczka ustawia
     się za pomocą funkcji <function>setcookie</function>. Ciasteczka są częścią
     nagłówka HTTP, więc funkcja SetCookie musi być wywołana zanim jakakolwiek
     inna informacja zostanie wysłana do przeglądarki. Takie samo ograniczenie
     dotyczy funkcji <function>header</function>. Dane z ciasteczek 
     są wówczas dostępne w odpowiednich tablicach danych cookies, takich 
     jak <varname>$_COOKIE</varname>, jak również <varname>$_REQUEST</varname>. 
     Zobacz także  stronę dotyczącą funkcji <function>setcookie</function> aby poznać więcej 
     informacji i przykładów.
    </simpara>

    <simpara>
     Jeśli chcesz przypisać wiele wartości do jednego ciasteczka, możesz
     po prostu złączyć je w tablicę. Na przykład:
    </simpara>

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
  setcookie("MojeCiasteczko[foo]", 'Test 1', time()+3600);
  setcookie("MojeCiasteczko[bar]", 'Test 2', time()+3600);
?>
]]>
     </programlisting>
    </informalexample>

    <simpara>
     Spowoduje to stworzenie dwóch oddzielnych ciasteczek, mimo, iż <varname>MojeCiasteczko</varname> będzie teraz
     pojedynczą tablicą w twoim skrypcie. Jeśli chcesz ustawić tylko jedno ciasteczko
     z wieloma wartościami, rozważ możliwość użycia przedtem funkcji <function>serialize</function>
     lub <function>explode</function> na wartości.
    </simpara>

    <simpara>
     Pamiętaj, że wysłane ciasteczko zastąpi wcześniejsze ciasteczko o tej
     nazwie, o ile ścieżka lub domena nie są różne. Na przykład dla koszyka
     do zakupów możesz potrzebować licznika a jego wartość stale przekazywać
     dalej, tzn.
    </simpara>

    <example>
     <title>Przykład użycia funkcji <function>setcookie</function></title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($_COOKIE['ile'])) {
    $ile = $_COOKIE['ile'] + 1;
} else {
    $ile = 1;
}
setcookie('ile', $ile, time()+3600);
setcookie("Cart[$ile]", $pozycja, time()+3600);
?>
]]>
     </programlisting>
    </example>

   </sect2>

   <sect2 xml:id="language.variables.external.dot-in-names">
    <title>Kropki w nazwach odbieranych zmiennych</title>

    <para>
     PHP normalnie nie zmienia nazw zmiennych podczas
     przekazywania ich do skryptu. Jednakże należy pamiętać, że
     kropka "." nie jest poprawnym znakiem w
     nazwie zmiennej PHP. Dlaczego? Proszę spojrzeć na to:
     <programlisting role="php">
<![CDATA[
<?php
$varname.ext;  /* niepoprawna nazwa zmiennej */
?>
]]>
     </programlisting>
     To co widzi parser, to zmienna o nazwie
     <varname>$varname</varname>, po której pojawia się operator konkatenacji,
     a następnie pusty łańcuch (czyli taki, który
     nie jest żadnym słowem kluczowym, ani zarezerwowanym) "ext". Oczywiście,
     nie daje to żadnego sensownego wyniku.
    </para>

    <para>
     Warto zatem wiedzieć, że PHP automatycznie
     zastąpi podkreślnikiem "_" każdą kropkę w nazwie każdej
     odebranej zmiennej.
    </para>

   </sect2>

   <sect2 xml:id="language.variables.determining-type-of">
    <title>Określanie typów zmiennych</title>

    <para>
     Ponieważ PHP samodzielnie określa typy zmiennych i konwertuje je
     (zasadniczo) jak potrzeba, nie zawsze jest jasne, jakiego typu jest dana
     zmienna w danym momencie. PHP zawiera kilka funkcji do określania typów
     zmiennych, takich jak:
     <function>gettype</function>, <function>is_array</function>,
     <function>is_float</function>, <function>is_int</function>,
     <function>is_object</function> i
     <function>is_string</function>. Zobacz także rozdział
     o <link linkend="language.types">Typach</link>.
    </para>
   </sect2>

   <sect2 xml:id="language.variables.external.changelog">
    &reftitle.changelog;

    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>5.4.0</entry>
         <entry>
          <link linkend="security.globals">Register Globals</link>, 
          <link linkend="security.magicquotes">Magic Quotes</link> i
          <link linkend="ini.register-long-arrays">register_long_arrays</link>
          zostały usunięte
         </entry>
        </row>
        <row>
         <entry>5.3.0</entry>
         <entry>
          <link linkend="security.globals">Register Globals</link>, 
          <link linkend="security.magicquotes">Magic Quotes</link> i
          <link linkend="ini.register-long-arrays">register_long_arrays</link>
          zostały zdeprecjonowane
         </entry>
        </row>
        <row>
         <entry>4.2.0</entry>
         <entry>
          Dyrektywa <link linkend="ini.register-globals">register_globals</link>
          jest domyślnie <emphasis>wyłączona</emphasis>.
         </entry>
        </row>
        <row>
         <entry>4.1.0</entry>
         <entry>
          <link linkend="language.variables.superglobals">Tablice superglobalne</link>, 
          like <varname>$_POST</varname> and <varname>$_GET</varname> stały się
          dostępne.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
