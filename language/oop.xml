<?xml version="1.0" encoding="iso-8859-2"?>
<!-- EN-Revision: 1.36 Maintainer: leszek Status: ready -->
<!-- $Revision: 1.13 $ -->
 <chapter id="language.oop">
  <title>Klasy i Obiekty</title>

  <sect1 id="keyword.class">
   <title><literal>klasa</literal></title>
   <para>
    Klasa jest to zbiór zmiennych i funkcji operuj±cych na tych zmiennych.
    Do definicji klasy u¿ywana jest nastêpuj±ca sk³adnia:
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Koszyk
{
    var $zakupy;  // Zakupy w naszym koszyku
   
    // Dodaj $num artyku³ów typu $artnr do wózka
 
    function dodaj_produkt ($artnr, $num)
    {
        $this->zakupy[$artnr] += $num;
    }
   
    // Usuñ $num artyku³ów typu $artnr z wózka
 
    function usun_produkt ($artnr, $num)
    {
        if ($this->zakupy[$artnr] > $num) {
            $this->zakupy[$artnr] -= $num;
            return true;
        } else {
            return false;
        }   
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    Definiuje to klasê o nazwie Koszyk, która zawiera tablicê asocjacyjn±
    artyku³ów znajduj±cych siê w wózku i dwie funkcje do dodawania i usuwania
    produktów z koszyka.
   </para>

   <caution>
    <simpara>
     Poni¿sze uwagi dotycz± PHP 4.
    </simpara>
    
    <simpara>
     Nazwa <literal>stdClass</literal> jest u¿ywana wewnêtrznie przez Zend i
     jest zarezerwowana. W PHP nie mo¿esz zdefiniowaæ klasy o nazwie
     <literal>stdClass</literal>.
    </simpara>
    
    <simpara>
      Nazwy funkcji <literal>__sleep</literal> i <literal>__wakeup</literal>
      maj± magiczne znaczenie dla klas w PHP. Klasy nie mog± zawieraæ funkcji
      o tych nazwach, chyba ¿e zgadzasz siê na przypisanie do nich magicznej
      funkcjonalno¶ci. Poni¿ej mo¿esz znale¼æ wiêcej informacji.
    </simpara>
    
    <simpara>
      PHP rezerwuje wszystkie nazwy funkcji zaczynaj±ce siê od __ na funkcje
      magiczne. Zalecane jest nieu¿ywanie funkcji z nazwami zaczynaj±cymi siê
      od __ chyba ¿e chcesz jakiej¶ magicznej funkcjonalno¶ci.
    </simpara>
   </caution>

   <note>
    <simpara>
     W PHP 4 dozwolone s± tylko sta³e inicjalizatory zmiennych
     <literal>var</literal>. Aby zainicjalizowaæ zmienne z nie-sta³ymi
     warto¶ciami, potrzebujesz funkcjê inicjalizacyjn±, która jest wywo³ywana
     automatycznie zaraz po utworzeniu obiektu z danej klasy. Taka funkcja
     zwana jest konstruktorem (zobacz poni¿ej).
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Nic z tego nie bêdzie dzia³aæ w PHP 4. */
class Koszyk
{
    var $dzisiejsza_data = date("Y-m-d");
    var $nazwa = $imie;
    var $wlasciciel = 'Fred ' . 'Jones';
    var $artykuly = array("VCR", "TV");
}

/* Teraz wszystko zadziala. */
class Koszyk
{
    var $dzisiejsza_data;
    var $nazwa;
    var $wlasciciel;
    var $artykuly;

    function Cart()
    {
        $this->dzisiejsza_data = date("Y-m-d");
        $this->nazwa = $GLOBALS['imie'];
        /* itp. . . */
    }
    }
?>
]]>
     </programlisting>
    </informalexample>
   </note>
   <para>
    Klasy s± typami, które s± w zasadzie tylko schematami dla w³a¶ciwych
    zmiennych. Zmienne po¿±danego typu musisz stworzyæ korzystaj±c z operatora
    <literal>new</literal>.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$koszyk = new Koszyk;
$koszyk->dodaj_produkt("10", 1);

$inny_koszyk = new Koszyk;
$inny_koszyk->dodaj_produkt("0815", 3);
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Kod ten tworzy obiekty $koszyk i $inny_koszyk, oba klasy Koszyk. Funkcja
    dodaj_produkt() obiektu $koszyk zostaje wywo³ana w celu dodania 1 artyku³u
    typu "10" do koszyka $koszyk. 4 przedmioty typu "0815" dodawane s± do
    koszyka $inny_koszyk.
   </para>
   
   <para>
    I $koszyk i $inny_koszyk maj± funkcje dodaj_produkt(), usun_produkt() i
    zmienne. S± to osobne funkcje i zmienne. Obiekty mog± byæ postrzegane jako
    katalogi w systemie plików. W systemie plików mo¿esz mieæ dwa ró¿ne pliki
    README.TXT, ale tylko je¶li istniej± w osobnych katalogach. Aby odczytaæ
    plik, bêd±c w g³ównym katalogu, musisz podaæ pe³n± ¶cie¿kê do tego pliku.
    Tak samo jest przy obiektach: musisz podaæ pe³n± nazwê funkcji, z której
    chcesz skorzystaæ. W terminologii PHP katalogiem g³ównym bêdzie globalna
    przestrzeñ nazw a separatorem ¶cie¿ki bêdzie -&gt;. W zwi±zku z tym nazwy
    $koszyk i $inny_koszyk zawieraj± zupe³nie inne zmienne. Zauwa¿, ¿e zmienna
    nazywa siê $koszyk-&gt;artykuly, a nie $koszyk-&gt;$artykuly, poniewa¿
    nazwa zmiennej mo¿e zawieraæ tylko jeden znak dolara.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
// poprawnie, jeden $
$koszyk->artykuly = array("10" => 1); 

// niepoprawnie, poniwa¿ $koszyk->$artykuly zamienia siê na $koszyk->""
$koszyk->$artykuly = array("10" => 1);

// poprawnie, ale mo¿e (ale nie musi) nie byæ tym, co zamierzali¶my:
// $koszyk->$zmienna staje siê $koszyk->artykuly
$zmienna = 'artykuly';
$koszyk->$zmienna = array("10" => 1);  
]]>
    </programlisting>
   </informalexample>

   <para>
    Wewn±trz definicji klasy, nie wiesz pod jak± nazw± obiekt bêdzie dostêpny
    dla twojego programu: w momencie pisania klasy Koszyk, nie by³o wiadomo,
    ¿e obiekty bêd± siê nazywaæ $koszyk lub $inny_koszyk. W zwi±zku z tym nie
    mo¿esz napisaæ $koszyk-&gt;artykuly wewn±trz klasy Koszyk. Zamiast tego,
    aby uzyskaæ dostêp do funkcji i zmiennych zawartych w klasie, mo¿na u¿yæ
    pseudo-zmiennej $this, która mo¿e byæ odczytana jako 'moje w³asne' lub
    'bie¿±cy obiekt'. A wiêc '$this-&gt;artykuly[$nrart] += $liczba' mo¿e byæ
    odczytane jako 'dodaj $liczba do licznika $nrart z mojej w³asnej tablicy
    artykuly' lub 'dodaj $liczba do licznika $nrartz tablicy artykuly zawartej
    w bie¿±cym obiekcie'.
   </para>

   <note>
    <para>
     Istnieje kilka przyjemnych funkcji do obs³ugi klas i obiektów. Mo¿esz je
     zobaczyæ w rozdziale <link linkend="ref.classobj">Funkcje obs³ugi klas i
      obiektów</link>
    </para>
   </note>
  </sect1>
  
  <sect1 id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    Bardzo czêsto zachodzi potrzeba stworzenia klasy o funkcjach i zmiennych
    podobnych do ju¿ istniej±cej klasy. Zasadniczo dobrze jest stworzyæ
    szablonow± klasê, która mo¿e byæ u¿yta we wszystkich twoich projektach i
    przystosowywaæ j± do specyficznych potrzeb twojego projektu. Aby u³atwiæ
    ten proces, klasy mog± byæ rozszerzeniami innych klas. Rozszerzone, lub
    mówi±c inaczej 'dziedziczone', klasy maj± wszystkie zmienne i funkcje
    klasy podstawowej (nazywa siê to dziedziczeniem, mimo ¿e nikt nie
    umar³) oraz to co do niej doda³e¶ w definicji rozszerzenia. Nie mo¿na
    odj±æ pewnych rzeczy z klasy podstawowej, czyli oddefiniowaæ istniej±cych
    w klasie podstawowej funkcji i zmiennych. Rozszerzona klasa jest zawsze
    zale¿na od jednej klasy bazowej - dziedziczenie wielokrotne nie jest
    obs³ugiwane. Klasy mo¿na rozszerzyæ u¿ywaj±c s³owa kluczowego 'extends'.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
class Nazwany_Koszyk extends Koszyk
{
    var $wlasciciel;
  
    function ustaw_wlasciciela ($nazwa)
    {
        $this->wlasciciel = $nazwa;
    }
}
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Definiuje to klasê Nazwany_Koszyk, który ma wszystkie zmienne i funkcje
    klasy Koszyk plus dodatkowa zmienna $wlasciciel i dodatkowa funkcja
    ustaw_wlasciciela(). Nazwany koszyk tworzy siê normalnym sposobem.
    Mo¿esz teraz ustawiaæ i pobieraæ nazwê w³a¶ciciela koszyka. Ca³y czas
    mo¿esz u¿ywaæ zwyk³ych funkcji koszyka dla nazwanego koszyka:
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
$nkoszyk = new Nazwany_Koszyk;        // Stwórz nazwany koszyk
$nkoszyk->ustaw_wlasciciela("kris");  // Nazwij koszyk
print $nkoszyk->wlasciciel;           // Wy¶wietl w³a¶ciciela koszyka
$nkoszyk->dodaj_przedmiot("10", 1);   // (funkcjonalno¶æ odziedziczona z
                                      // koszyka)
]]>
    </programlisting>
   </informalexample>
   <para>
    Taka relacja nazywana jest czêsto relacj± "rodzic-potomek". Tworzysz
    klasê - rodzica - i u¿ywasz <literal>extends</literal> aby stworzyæ klasê
    <emphasis>opart±</emphasis> o klasê rodzica: klasê potomn±. Mo¿esz tak¿e
    tworzyæ nowe klasy potomne oparte o t± klasê potomn±.
   </para>
   <note>
    <para>
     Klasy musza byæ zdefiniowane zanim zostan± u¿yte! Je¶li chcesz, aby klasa
     <literal>Nazwany_Koszyk</literal> rozszerza³a klasê
     <literal>Koszyk</literal>, musisz zdefiniowaæ klasê
     <literal>Koszyk</literal> jako pierwsz±. Je¶li chcesz stworzyæ kolejn±
     klasê nazwan± <literal>Niebieski_Nazwany_Koszyk</literal> opart± o
     klasê <literal>Nazwany_Koszyk</literal>, musisz najpierw zdefiniowaæ
     klasê <literal>Nazwany_Koszyk</literal>. W skrócie: kolejno¶æ, w jakiej
     klasy s± definiowane, jest bardzo wa¿na.
    </para>
   </note>
  </sect1>

  <sect1 id="language.oop.constructor">
   <title><literal>Konstruktory</literal></title>

   <caution>
    <simpara>
     Konstruktory zachowuj± siê inaczej w PHP 3 i w PHP 4. Semantyka PHP 4
     jest mocno zalecana.
    </simpara>
   </caution>

   <para>
    Konstruktory s± funkcjami klasy, które s± automatycznie wywo³ywane przy
    tworzeniu nowej instancji klasy korzystaj±c z operatora
    <literal>new</literal>. W PHP 3 funkcja staje siê konstruktorem kiedy ma
    tak± sam± nazwê jak klasa. W PHP 4 funkcja staje siê konstruktorem, kiedy
    ma tak± sam± nazwê jak klasa, w której ta funkcja zosta³a zdefiniowana -
    ró¿nica jest subtelna, ale bardzo wa¿na (zobacz poni¿ej)
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
// Dzia³a w PHP 3 i PHP 4.
class Auto_Koszyk extends Koszyk
{
    function Auto_Koszyk()
    {
        $this->dodaj_artykul ("10", 1);
    }
}
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Ten kod definiujê klasê Auto_Koszyk, który jest klas± Koszyk pluc
    konstruktor, który inicjalizuje wózek z jednym artyku³em "10" za ka¿dym
    razem, kiedy Auto_Koszyk jest tworzony operatorem "new". Konstruktory mog±
    pobieraæ argumenty i te argumenty mog± byæ opcjonalne, przez co s± jeszcze
    bardziej u¿yteczne. Aby w dalszym ci±gu móc u¿ywaæ klasy bez parametrów,
    wszystkie parametry konstruktora powinny staæ siê opcjonalne przez dodanie
    domy¶lnych warto¶ci.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
// Dzia³a w PHP 3 i PHP 4.
class Kontruktor_Koszyk extends Koszyk
{
    function Konstruktor_Koszyk($artykul = "10", $ilosc = 1)
    {
        $this->dodaj_artykul ($artykul, $ilosc);
    }
}
 
// Kup te same nudne rzeczy...
 
$zwykly_koszyk = new Konstruktor_Koszyk;
 
// Czas na prawdziwe zakupy...
 
$inny_koszyk = new Konstruktor_Koszyk("20", 17);
]]>
    </programlisting>
   </informalexample>

   <para>
    Mo¿esz tak¿e u¿yæ operatora <literal>@</literal> aby
    <emphasis>wyciszyæ</emphasis> b³êdy zachodz±ce w konstruktorze, np.
    <literal>@new</literal>
   </para>
   <caution>
    <simpara>
     W PHP 3, dziedziczone klasy i konstruktory maj± wiele ograniczeñ.
     Poni¿sze przyk³ady powinny byæ dok³adnie przeczytane w celu zrozumienia
     tych ograniczeñ.
    </simpara> 
   </caution>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function A()
    {
      echo "Jestem konstruktorem klasy A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "Zwyk³a funkcja.<br>\n";
    }
}

// W PHP 3 nie zostanie wywo³any ¿aden konstruktor.
$b = new B;
]]>
    </programlisting>
   </informalexample>

   <para>
    W PHP 3 w powy¿szym przyk³adzie nie bêdzie wywo³any ¿aden konstruktor.
    Zasad± PHP 3 jest: 'Konstruktor to funkcja o takiej samej nazwie jak
    klasa'. Nazw± klasy jest B, a w klasie B nie ma funkcji o nazwie B(). Nic
    siê nie dzieje.
   </para>
   
   <para>
    Zosta³o to poprawione w PHP 4 przez wprowadzenie innej zasady: je¶li klasa
    nie ma konstruktora, u¿ywany jest konstruktor klasy bazowej, je¶li taki
    istnieje. W PHP 4 powy¿szy przyk³ad wy¶wietli 'Jestem konstruktorem klasy
    A.&lt;br>'.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function A()
    {
        echo "Jestem konstruktorem klasy A.<br>\n";
    }

    function B()
    {
        echo "Jestem zwyk³± funkcj± o nazwie B w klasie A.<br>\n";
        echo "Nie jestem konstruktorem w klasie A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "Jestem zwyk³± funkcj±.<br>\n";
    }
}

// Wywo³a to B() jako konstruktor.
$b = new B;
]]>
    </programlisting>
   </informalexample>
   
   <para>
    W PHP 3, funkcja B() z klasy A niespodziewanie stanie siê konstruktorem w
    klasie B, pomimo ¿e wcale nie mia³a nim byæ. Zasad± PHP 3 jest:
    'Konstruktor to funkcja o takiej samej nazwie co klasa'. PHP 3 nie
    obchodzi czy funkcja zosta³a zdefiniowana w klasie B czy zosta³a
    odziedziczona.
   </para>
   
   <para>
    Zosta³o to poprawione w PHP 4 przez modyfikacjê tej zasady do:
    'Konstruktor to funkcja o tej samej nazwie co klasa w której zosta³a
    zdefiniowana'. W zwi±zku z tym w PHP 4 clasa B nie mia³aby w³asnego
    konstruktora. Wywo³any by³by tylko konstruktor klasy bazowej, wy¶wietlaj±c
    'Jestem konstruktorem klasy A.&lt;br>'.
   </para>
   
   <caution>
    <simpara>
     Ani PHP 3 ani PHP 4 nie wywo³a automatycznie konstruktora klasy bazowej z
     kontruktora klasy pochodnej. Twoim zadaniem jest propagacja wywo³añ
     konstruktorów klas nadrzêdnych, je¶li to konieczne.
    </simpara>
   </caution>
   
   <note>
    <simpara>
     Ani w PHP 3 ani w PHP 4 nie ma destruktorów. Zamiast tego mo¿esz u¿yæ
     <function>register_shutdown_function</function> aby symulowaæ dzia³anie
     destruktorów.
    </simpara>
   </note>
   
   <para>
    Destruktory s± funkcjami, które s± wywo³ywanie automatycznie kiedy obiekty
    s± niszczone albo przez u¿ycie <function>unset</function> albo przez
    wyj¶cie z zasiêgu. W PHP nie ma destruktorów.
   </para>
  </sect1>

 <sect1 id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title><literal>::</literal></title>

   <caution>
    <simpara>
     Poni¿sze dotyczy tylko PHP 4.
    </simpara>
   </caution>

   <para>
    Czasami dobrze jest odnosiæ siê do funkcji i zmiennych w klasie bazowej
    lub odnosiæ siê do funkcji i klas które nie maj± jeszcze instancji. S³u¿y
    do tego operator ::.
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function przyklad()
    {
        echo "Jestem orginaln± funkcj± A::przyklad().<br>\n";
    }
}

class B extends A
{
    function przyklad()
    {
        echo "Jestem przedefiniowan± funkcj± B::przyklad().<br>\n";
        A::przyklad();
    }
}

// nie ma obiektu klasy A.
// poni¿sze wy¶wietli
//   Jestem orginaln± funkcj± A::przyklad().<br>
A::przyklad();

// stwórz nowy obiekt klasy B.
$b = new B;

// poni¿sze wy¶wietli
//   Jestem przedefiniowan± funkcj± B::przyklad().<br>
//   Jestem orginaln± funkcj± A::przyklad().<br>
$b->przyklad();
]]>
    </programlisting>
   </informalexample>

   <para>
    Powy¿szy przek³ad wywo³uje funkcjê przyklad() z klasy A, ale nie tworz±c
    obiektu tej klasy, przez co nie mo¿emy napisaæ nic w stylu $a->przyklad().
    Zamiast tego mo¿emy wywo³aæ przyklad() jako 'funkcjê klasy', czyli jako
    funkcjê tylko klasy, nie ¿adnego obiektu tej klasy.
   </para>
   
   <para>
    Istniej± funkcje klasy, ale nie ma zmiennych klasy. Faktycznie w czasie
    wykonania nie ma ¿adnego obiektu. W zwi±zku z tym funkcje klasy nie mog±
    u¿ywaæ ¿adnych zmiennych obiektu (ale mog± u¿ywaæ zmiennych lokalnych i
    globalnych), ani w ogóle $this.
   </para>

   <para>
    W powy¿szym przyk³adzie, klasa B przedefiniowuje funkcjê przyklad().
    Orginalna definicja z klasy A jest zas³oniêta i niedostêpna, chyba ¿e
    odwo³asz siê do konkretnej implementacji poprzez operator ::. Aby to
    zrobiæ, napisz A::przyklad() (powiniene¶ jednak u¿yæ parent::przyklad(),
    tak jak to pokazano w nastêpnej czê¶ci).
   </para>
   
   <para>
    W tym kontek¶cie, istnieje bie¿±cy obiekt i który ma zmienne obiektu. W
    zwi±zu z tym je¶li funkcja jest u¿yta Z WEWN¡TRZ funkcji obiektu, mo¿esz
    u¿ywaæ $this i zmiennych obiektu.
   </para>

 </sect1>

 <sect1 id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   Mo¿e siê zdarzyæ, ¿e bêdziesz pisa³ kod, który odnosi siê do funkcji i
   zmiennych klasy bazowej. Jest to mo¿liwe je¶li twoja klasa pochodna jest
   u¶ci¶leniem lub specjalizacj± klasy bazowej.
  </para>
  
  <para>
   Zamiast jawnego podawania nazwy klasy bazowej w kodzie, powiniene¶ u¿yæ
   specjalnej nazwy <literal>parent</literal>, która odnosi siê do nazwy klasy
   bazowej podanej przy <literal>extends</literal> podczas deklaracji twojej
   klasy. Robi±c to, unikasz u¿ycia nazwy klasy bazowej w wiêcej ni¿ jednym
   miejscu. Je¶li twoje drzewo dziedziczenia zmieni³oby siê podczas
   implementacji, zmiana bêdzie wymaga³a poprawki tylko w jednym miejscu -
   przy s³owie kluczowym <literal>extends</literal> w deklaracji klasy.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
class A
{
    function przyklad()
    {
        echo "Jestem A::przyklad() I dostarczam podstawow± funkcjonalno¶æ.<br>\n";
    }
}

class B extends A
{
    function przyklad()
    {
        echo "Jestem B::przyklad() i dostarczam dodatkow± funkcjonalno¶æ.<br>\n";
        parent::przyklad();
    }
}

$b = new B;

// Wywo³a to B::przyklad(), który z kolei wywo³a A::przyklad().
$b->przyklad();
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 id="language.oop.serialization">
  <title>Serializacja obiektów - obiekty w sesjach</title>

  <note>
   <simpara>
    W PHP 3 obiekty trac± powi±zania miêdzy klasami w czasie procesu
    serializacji i odserializacji. Wynikowa zmienna bêdzie typu obiekt, ale
    bez klasy i bez metod, a wiêc w zasadzie bezu¿yteczn± (zostanie poprostu
    zmienn± ze ¶mieszn± sk³adni±).
   </simpara>
  </note>

  <caution>
   <simpara>
    Poni¿sze informacje dotycz± tylko PHP 4.
   </simpara>
  </caution>

  <para>
   <function>serialize</function> zwraca string bêd±cy reprezentacj± dowolnej
   warto¶ci, która mo¿e byæ przechowywana przez PHP.
   <function>unserialize</function> mo¿e u¿yæ tego stringu aby odtworzyæ
   orginalne warto¶ci zmiennej. U¿ycie serializacji do zapisania obiektu
   zachowa wszystkie zmienne z obiektu. Zapisane nie bêd± funkcje z obiektu, a
   jedynie nazwa klasy.
  </para>
  
  <para>
   Aby istnia³a mo¿liwo¶æ u¿ycia funkcji <function>unserialize</function> do
   odzyskania obiektu, musi byæ zdefiniowana klasa tego obiektu. Oznacza to,
   ¿e je¶li obiekt $a klasy A istnieje na page1.php i zserializujesz go,
   otrzymasz string, który odnosi siê do klasy A i zawiera warto¶ci wszystkich
   zmiennych zawartych w $a. Je¶li chcesz, aby istnia³a mo¿liwo¶æ
   odserializacji tego obiektu na page2.php, na page2.php musi istnieæ
   definicja klasy A. Mo¿na to zrobiæ na przyk³ad przez przechowywanie
   definicji klasy A w zewnêtrznym pliku includowanym przez page1.php i
   page2.php.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
classa.inc:
  class A 
  {
      var $jeden = 1;
    
      function pokaz_jeden()
      {
          echo $this->jeden;
      }
  }
  
page1.php:
  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // przechowaj $s gdzie¶, gdzie page2.php bêdzie mog³a go znale¼æ
  $fp = fopen("store", "w");
  fputs($fp, $s);
  fclose($fp);

page2.php:
  // to jest niezbêdne aby funkcja unserialize dzia³a³a prawid³owo.
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // teraz u¿yj funkcji pokaz_jeden z obiektu $a.
  $a->pokaz_jeden();
]]>
   </programlisting>
  </informalexample>
  
  <para>
   Je¶li u¿ywasz sesji i <function>session_register</function> do rejestracji
   obiektów, te obiekty s± serializowane automatycznie na koñcu ka¿dej strony
   PHP i odserializowane automatycznie na ka¿dej z nastêpnych stron.
   Zasadniczo znaczy to, ¿e te obiekty mog± pokazaæ siê na dowolnej z twoich
   stron je¶li tylko stan± siê czê¶ci± twojej sesji.
  </para>
  
  <para>
   Mocno zalecane jest includowanie definicji klas wszystkich zarejestrowanych
   obiektów na wszystkich twoich stronach, nawet je¶li nie u¿ywasz tych
   zmiennych na twoich stronach. Je¶li tego nie zrobisz a obiekty zostan±
   odserializowane bez definicji klasy, powi±zania klasowe zostan± utracone a
   obiek stanie siê obiektem klasy <literal>stdClass</literal> bez ¿adnych
   dostêpnych funkcji, a wiêc bêdzie ca³kiem bezu¿yteczny.
  </para>
  
  <para>
   A wiêc je¶li w powy¿szym przyk³adzie $a stanie siê czê¶ci± sesji przez
   wywo³anie <literal>session_register("a")</literal>, powinieneæ includowaæ
   plik <literal>classa.inc</literal> na wszystkich stronach, nie tylko
   page1.php i page2.php.
  </para>
 </sect1>

 <sect1 id="language.oop.magic-functions">
  <title>Magiczne funkcje <literal>__sleep</literal> i <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> sprawdza, czy twoja klasa zawiera funkcjê o
   magicznej nazwie <literal>__sleep</literal>. Je¶li tak, ta funkcja jest
   wywo³ywana przed ka¿d± serializacj±. Mo¿e ona czy¶ciæ obiekt i powinna
   zwracaæ tablicê z nazwami wszystkich zmiennych obiektu, które powinny byæ
   serializowane.
  </para>
  
  <para>
   Za³o¿onym u¿yciem <literal>__sleep</literal> jest zamkniêcie wszystkich
   po³±czeñ do baz danych, które obiekt mo¿e utrzymywaæ, zatwierdzenie
   wszystkich oczekuj±cych danych lub wykonanie innych podobnych czynno¶ci
   czyszcz±cych. Funkcja ta jest tak¿e przydatna je¶li masz bardzo du¿e
   obiekty, które nie musz± byæ zachowane w ca³o¶ci.
  </para>
  
  <para>
   Analogicznie, <function>unserialize</function> sprawdza czy istnieje
   funkcja o magicznej nazwie <literal>__wakeup</literal>. Je¶li tak, funkcja
   mo¿e rekonstruowaæ dowolne zasoby które obiekt mo¿e posiadaæ.
  </para>
  
  <para>
    Za³o¿onym u¿yciem <literal>__wakeup</literal> jest odnowienie po³±czeñ z
    bazami danych, które mog³y zostac utracone w procesie serializacji, oraz
    wykonanie innych czynno¶ci odbudowuj±cych obiekt.
  </para>
 </sect1>
  
 <sect1 id="language.oop.newref">
   <title>Referencje wewn±trz konstruktora</title>
   <para>
    Tworzenie referencji wewn±trz konstruktora mo¿e prowadziæ do dziwnych
    efektów. Ten rozdzia³ ma pomóc w unikaniu takich problemów.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
class Foo
{
    function Foo($nazwa)
    {
        // stworz referencje wewnatrz globalnej tablicy $globalref
        global $globalref;
        $globalref[] = &$this;
        // ustaw nazwê na przekazan± warto¶æ
        $this->ustawNazwe($nazwa);
        // i wy¶wietl j±
        $this->wyswietlNazwe();
    }

    function wyswietlNazwe()
    {
        echo "<br>",$this->nazwa;
    }
	
    function ustawNazwe($nazwa)
    {
        $this->nazwa = $nazwa;
    }
}
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    Sprawd¼my, czy jest jaka¶ ró¿nica pomiêdzy
    <varname>$bar1</varname>, który jest tworzony przy pomocy operatora
    przypisania <literal>=</literal>, a <varname>$bar2</varname>, który zosta³
    stworzony u¿ywaj±c operatora referencji <literal>=&amp;</literal>...

    <informalexample>
     <programlisting role="php">
<![CDATA[
$bar1 = new Foo('ustawione w konstruktorze');
$bar1->wyswietlNazwe();
$globalref[0]->wyswietlNazwe();

/* wyj¶cie:
ustawione w konstruktorze
ustawione w konstruktorze
ustawione w konstruktorze */

$bar2 =& new Foo('ustawione w konstruktorze');
$bar2->wyswietlNazwe();
$globalref[1]->wyswietlNazwe();

/* wyj¶cie:
ustawione w konstruktorze
ustawione w konstruktorze
ustawione w konstruktorze */
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Wydaje siê, ¿e nie ma ¿adnej ró¿nicy, ale na prawdê jest jedna, i to
    bardzo istotna: <varname>$bar1</varname> i
    <varname>$globalref[0]</varname> <emphasis>NIE</emphasis> s± referencjami,
    <emphasis>NIE</emphasis> s± t± sam± zmienna. Dzieje siê tak, poniewa¿
    "new" nie zwraca domy¶lnie referencji, ale kopiê.
    <note>
     <simpara>
      Zwracanie kopii zamiast referencji nie powoduje utraty wydajno¶ci (od
      PHP 4 u¿ywane jest zliczanie referencji). Jednak¿e zazwyczaj lepiej jest
      pracowaæ poprostu z kopiami zamiast referencji, poniewaæ tworzenie
      referencji zabiera trochê czasu, podczas gdy tworzenie kopii obiektów
      teoretycznie w ogóle nie zabiera czasu (chyba ¿e która¶ z tych zmiennych
      jest du¿± tablic± lub obiektem i jedno z nich ulega zmianie, po czym tej
      samej zmianie ulegaj± pozosta³e zmienne; wtedy lepiej jest u¿yæ
      referencji do zmieniania ich równolegle).
     </simpara>
    </note>
    Aby udowodniæ to, co zosta³o zapisane powy¿ej, przyjrzyjmy siê poni¿szemu
    programowi.

    <informalexample>
     <programlisting role="php">
<![CDATA[
// teraz zmienimy nazwê. czego siê spodziewasz?
// mo¿esz siê spodziewaæ, ¿e i $bar1 i $globalref[0] zmieni± swoje nazwy...
$bar1->ustawNazwe('ustawiona z zewn±trz');

// jak napisano powy¿ej, nic takiego siê nie stanie
$bar1->wyswietlNazwe();
$globalref[0]->wyswietlNazwe();

/* wyj¶cie:
ustawiona z zewn±trz
ustawiona w konstruktorze */

// zobaczmy co siê dzieje z $bar2 i $globalref[1]
$bar2->ustawNazwe('ustawiona z zewn±trz');

// na szczê¶cie ta zmienna nie zachowuje siê jak ta z poprzedniego przypadku
// s± to te same zmienne, z wiêc $bar2->nazwa i $globalref[1]->nazwa s± tak¿e
// tymi samymi zmiennymi
$bar2->wyswietlNazwe();
$globalref[1]->wyswietlNazwe();

/* wyj¶cie:
ustawiona z zewn±trz
ustawiona z zewn±trz */
]]>
     </programlisting>
    </informalexample>   
   </para>   
   <para>
   Ustatni przyk³ad. Postaraj siê go zrozumieæ/
   
    <informalexample>
     <programlisting role="php">
<![CDATA[
class A
{
    function A($i)
    {
        $this->wartosc = $i;
        // domy¶l siê dlaczego nie potrzebujemy tutaj referencji
        $this->b = new B($this);
    }

    function stworzRef()
    {
        $this->c = new B($this);
    }

    function wyswietlWartosc()
    {
        echo "<br>","klasa ",get_class($this),': ',$this->value;
    }
}


class B
{
    function B(&$a)
    {
        $this->a = &$a;
    }

    function wyswietlWartosc()
    {
        echo "<br>","klasa ",get_class($this),': ',$this->a->value;
    }
}
// spróbuj zrozumieæ dlaczego u¿ycie tu prostego kopiowania mo¿e powodowaæ
// nieporz±dany efekt w linii uznaczonej znaczkiem '*'
$a =& new A(10);
$a->stworzRef();

$a->wyswietlWartosc();
$a->b->wyswietlWartosc();
$a->c->wyswietlWartosc();

$a->value = 11;

$a->wyswietlWartosc();
$a->b->wyswietlWartosc(); // *
$a->c->wyswietlWartosc();

/*
wyj¶cie:
klasa A: 10
klasa B: 10
klasa B: 10
klasa A: 11
klasa B: 11
klasa B: 11
*/
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
